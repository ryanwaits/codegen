import { format } from "prettier";
import type { ResolvedContract } from "../types/config.js";
import type { ClarityFunction } from "clarity-abitype";

/**
 * Code generator for contract interfaces
 */

export async function generateContractInterface(
  contracts: ResolvedContract[],
  runtime: "minimal" | "full" = "minimal"
): Promise<string> {
  const baseImports = `import type { ContractCallParams, ReadOnlyCallParams } from 'clarity-abitype'
import { Cl, validateStacksAddress } from '@stacks/transactions'`;

  const fullRuntimeImports =
    runtime === "full"
      ? `import { fetchCallReadOnlyFunction, makeContractCall } from '@stacks/transactions'
import { openContractCall } from '@stacks/connect'`
      : "";

  const imports = fullRuntimeImports
    ? `${baseImports}\n${fullRuntimeImports}`
    : baseImports;

  const header = `/**
 * Generated by @stacks/codegen
 * DO NOT EDIT MANUALLY
 */`;

  const contractsCode = contracts
    .map((contract) => generateContract(contract, runtime))
    .join("\n\n");

  const code = `${imports}\n\n${header}\n\n${contractsCode}`;

  const formatted = await format(code, {
    parser: "typescript",
    singleQuote: true,
    semi: true,
    printWidth: 100,
    trailingComma: "es5",
  });

  return formatted;
}

function generateContract(
  contract: ResolvedContract,
  runtime: "minimal" | "full"
): string {
  const { name, address, contractName, abi } = contract;

  const abiCode = generateAbiConstant(name, abi);

  const methods = abi.functions
    .filter((func: ClarityFunction) => func.access !== "private")
    .map((func: ClarityFunction) => generateMethod(func, address, contractName))
    .join(",\n\n  ");

  // Generate helper functions for full runtime
  const helpers =
    runtime === "full"
      ? generateHelperFunctions(abi, address, contractName)
      : "";

  const contractCode = `export const ${name} = {
  address: '${address}',
  contractAddress: '${address}',
  contractName: '${contractName}',
  
  ${methods}${helpers ? `,\n\n  ${helpers}` : ""}
} as const`;

  return `${abiCode}\n\n${contractCode}`;
}

function generateAbiConstant(name: string, abi: any): string {
  const abiJson = JSON.stringify(abi, null, 2)
    .replace(/"([a-zA-Z_$][a-zA-Z0-9_$]*)":/g, "$1:") // Only remove quotes from valid JS identifiers
    .replace(/"/g, "'"); // Use single quotes

  return `export const ${name}Abi = ${abiJson} as const`;
}

function generateMethod(
  func: ClarityFunction,
  address: string,
  contractName: string
): string {
  const methodName = toCamelCase(func.name);

  if (func.args.length === 0) {
    return `${methodName}() {
    return {
      contractAddress: '${address}',
      contractName: '${contractName}',
      functionName: '${func.name}',
      functionArgs: []
    }
  }`;
  }

  if (func.args.length === 1) {
    const originalArgName = func.args[0].name;
    const argName = toCamelCase(originalArgName);
    const argType = getTypeForArg(func.args[0]);
    const clarityConversion = generateClarityConversion(argName, func.args[0]);

    return `${methodName}(...args: [{ ${argName}: ${argType} }] | [${argType}]) {
    const ${argName} = args.length === 1 && typeof args[0] === 'object' && args[0] !== null && '${argName}' in args[0]
      ? args[0].${argName}
      : args[0] as ${argType}
    
    return {
      contractAddress: '${address}',
      contractName: '${contractName}',
      functionName: '${func.name}',
      functionArgs: [${clarityConversion}]
    }
  }`;
  }

  const argsList = func.args.map((arg) => toCamelCase(arg.name)).join(", ");
  const argsTypes = func.args
    .map((arg) => {
      const camelName = toCamelCase(arg.name);
      return `${camelName}: ${getTypeForArg(arg)}`;
    })
    .join("; ");
  const argsArray = func.args
    .map((arg) => {
      const argName = toCamelCase(arg.name);
      return generateClarityConversion(argName, arg);
    })
    .join(", ");
  const objectAccess = func.args
    .map((arg) => {
      const camelName = toCamelCase(arg.name);
      return `args[0].${camelName}`;
    })
    .join(", ");
  const positionTypes = func.args.map((arg) => getTypeForArg(arg)).join(", ");

  return `${methodName}(...args: [{ ${argsTypes} }] | [${positionTypes}]) {
    const [${argsList}] = args.length === 1 && typeof args[0] === 'object' && args[0] !== null
      ? [${objectAccess}]
      : args as [${positionTypes}]
    
    return {
      contractAddress: '${address}',
      contractName: '${contractName}',
      functionName: '${func.name}',
      functionArgs: [${argsArray}]
    }
  }`;
}

function getTypeForArg(arg: any): string {
  const type = arg.type;

  if (typeof type === "string") {
    switch (type) {
      case "uint128":
      case "int128":
        return "bigint";
      case "bool":
        return "boolean";
      case "principal":
        return "string";
      default:
        return "any";
    }
  }

  if (type["string-ascii"] || type["string-utf8"]) {
    return "string";
  }

  if (type.buff) {
    // Support flexible buffer input types
    return "Uint8Array | string | { type: 'ascii' | 'utf8' | 'hex'; value: string }";
  }

  if (type.optional) {
    const innerType = getTypeForArg({ type: type.optional });
    return `${innerType} | null`;
  }

  if (type.list) {
    const innerType = getTypeForArg({ type: type.list.type });
    return `${innerType}[]`;
  }

  if (type.tuple) {
    const fields = type.tuple
      .map(
        (field: any) => `${field.name}: ${getTypeForArg({ type: field.type })}`
      )
      .join("; ");
    return `{ ${fields} }`;
  }

  if (type.response) {
    const okType = getTypeForArg({ type: type.response.ok });
    const errType = getTypeForArg({ type: type.response.error });
    return `{ ok: ${okType} } | { err: ${errType} }`;
  }

  return "any";
}

function toCamelCase(str: string): string {
  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Convert TypeScript value to ClarityValue based on the argument type
 */
function generateClarityConversion(argName: string, argType: any): string {
  const type = argType.type;

  if (typeof type === "string") {
    switch (type) {
      case "uint128":
        return `Cl.uint(${argName})`;
      case "int128":
        return `Cl.int(${argName})`;
      case "bool":
        return `Cl.bool(${argName})`;
      case "principal":
        return `(() => {
          const value = ${argName};
          if (!validateStacksAddress(value.split('.')[0])) {
            throw new Error('Invalid Stacks address format');
          }
          if (value.includes('.')) {
            const [address, contractName] = value.split('.');
            return Cl.contractPrincipal(address, contractName);
          } else {
            return Cl.standardPrincipal(value);
          }
        })()`;
      default:
        return `${argName}`; // fallback for unknown types
    }
  }

  if (type["string-ascii"]) {
    return `Cl.stringAscii(${argName})`;
  }

  if (type["string-utf8"]) {
    return `Cl.stringUtf8(${argName})`;
  }

  if (type.buff) {
    // Generate flexible buffer conversion code that matches the hooks implementation
    return `(() => {
      const value = ${argName};
      // Direct Uint8Array
      if (value instanceof Uint8Array) {
        return Cl.buffer(value);
      }
      // Object notation with explicit type
      if (typeof value === 'object' && value !== null && value.type && value.value) {
        switch (value.type) {
          case 'ascii':
            return Cl.bufferFromAscii(value.value);
          case 'utf8':
            return Cl.bufferFromUtf8(value.value);
          case 'hex':
            return Cl.bufferFromHex(value.value);
          default:
            throw new Error(\`Unsupported buffer type: \${value.type}\`);
        }
      }
      // Auto-detect string type
      if (typeof value === 'string') {
        // Check for hex (0x prefix or pure hex pattern)
        if (value.startsWith('0x') || /^[0-9a-fA-F]+$/.test(value)) {
          return Cl.bufferFromHex(value);
        }
        // Check for non-ASCII characters (UTF-8)
        if (!/^[\\x00-\\x7F]*$/.test(value)) {
          return Cl.bufferFromUtf8(value);
        }
        // Default to ASCII for simple ASCII strings
        return Cl.bufferFromAscii(value);
      }
      throw new Error(\`Invalid buffer value: \${value}\`);
    })()`;
  }

  if (type.optional) {
    const innerConversion = generateClarityConversion(argName, {
      type: type.optional,
    });
    return `${argName} !== null ? Cl.some(${innerConversion.replace(argName, `${argName}`)}) : Cl.none()`;
  }

  if (type.list) {
    const innerConversion = generateClarityConversion("item", {
      type: type.list.type,
    });
    return `Cl.list(${argName}.map(item => ${innerConversion}))`;
  }

  if (type.tuple) {
    const fields = type.tuple
      .map((field: any) => {
        const fieldConversion = generateClarityConversion(
          `${argName}.${field.name}`,
          { type: field.type }
        );
        return `${field.name}: ${fieldConversion}`;
      })
      .join(", ");
    return `Cl.tuple({ ${fields} })`;
  }

  if (type.response) {
    // For response types, we expect the user to pass { ok: value } or { err: value }
    const okConversion = generateClarityConversion(`${argName}.ok`, {
      type: type.response.ok,
    });
    const errConversion = generateClarityConversion(`${argName}.err`, {
      type: type.response.error,
    });
    return `'ok' in ${argName} ? Cl.ok(${okConversion.replace(`${argName}.ok`, `${argName}.ok`)}) : Cl.error(${errConversion.replace(`${argName}.err`, `${argName}.err`)})`;
  }

  // Default fallback
  return `${argName}`;
}

function generateHelperFunctions(
  abi: any,
  address: string,
  contractName: string
): string {
  const readFunctions = abi.functions.filter(
    (func: ClarityFunction) => func.access === "read-only"
  );
  const writeFunctions = abi.functions.filter(
    (func: ClarityFunction) => func.access === "public"
  );

  const readHelpers =
    readFunctions.length > 0
      ? generateReadHelpers(readFunctions, address, contractName)
      : "";

  const writeHelpers =
    writeFunctions.length > 0
      ? generateWriteHelpers(writeFunctions, address, contractName)
      : "";

  const fetchHelpers =
    writeFunctions.length > 0
      ? generateFetchHelpers(writeFunctions, address, contractName)
      : "";

  const parts = [readHelpers, writeHelpers, fetchHelpers].filter(Boolean);
  return parts.join(",\n\n  ");
}

function generateReadHelpers(
  functions: ClarityFunction[],
  address: string,
  contractName: string
): string {
  const helpers = functions.map((func) => {
    const methodName = toCamelCase(func.name);
    const argsSignature = generateArgsSignature(func.args);

    return `async ${methodName}(${argsSignature}options?: { 
      network?: 'mainnet' | 'testnet' | 'devnet';
      senderAddress?: string;
    }) {
      const { network = 'mainnet', senderAddress = 'SP000000000000000000002Q6VF78' } = options || {};
      
      return await fetchCallReadOnlyFunction({
        contractAddress: '${address}',
        contractName: '${contractName}',
        functionName: '${func.name}',
        functionArgs: [${generateClarityArgs(func.args)}],
        network,
        senderAddress
      });
    }`;
  });

  return `read: {\n    ${helpers.join(",\n\n    ")}\n  }`;
}

function generateWriteHelpers(
  functions: ClarityFunction[],
  address: string,
  contractName: string
): string {
  const helpers = functions.map((func) => {
    const methodName = toCamelCase(func.name);
    const argsSignature = generateArgsSignature(func.args);

    return `async ${methodName}(${argsSignature}options: {
      senderKey: string;
      network?: 'mainnet' | 'testnet' | 'devnet';
      fee?: string | number | undefined
      nonce?: bigint;
      anchorMode?: 1 | 2 | 3; // AnchorMode: OnChainOnly = 1, OffChainOnly = 2, Any = 3
      postConditions?: any[]; // TODO: Add proper PostCondition types
      validateWithAbi?: boolean;
    }) {
      const { senderKey, network = 'mainnet', ...txOptions } = options;
      
      // TODO: Add error handling and retry logic
      return await makeContractCall({
        contractAddress: '${address}',
        contractName: '${contractName}',
        functionName: '${func.name}',
        functionArgs: [${generateClarityArgs(func.args)}],
        senderKey,
        network,
        validateWithAbi: true,
        ...txOptions
      });
    }`;
  });

  return `write: {\n    ${helpers.join(",\n\n    ")}\n  }`;
}

function generateFetchHelpers(
  functions: ClarityFunction[],
  address: string,
  contractName: string
): string {
  const helpers = functions.map((func) => {
    const methodName = `fetch${toCamelCase(func.name).charAt(0).toUpperCase() + toCamelCase(func.name).slice(1)}`;
    const argsSignature = generateArgsSignature(func.args);

    return `async ${methodName}(${argsSignature}options?: {
      onFinish?: (data: any) => void;
      onCancel?: () => void;
      fee?: string | number | undefined
      anchorMode?: 1 | 2 | 3; // AnchorMode: OnChainOnly = 1, OffChainOnly = 2, Any = 3
      postConditions?: any[]; // TODO: Add proper PostCondition types
    }) {
      // TODO: Add error handling for wallet connection
      return await openContractCall({
        contractAddress: '${address}',
        contractName: '${contractName}',
        functionName: '${func.name}',
        functionArgs: [${generateClarityArgs(func.args)}],
        ...options
      });
    }`;
  });

  return helpers.join(",\n\n  ");
}

function generateArgsSignature(args: readonly any[]): string {
  if (args.length === 0) return "";

  const argsTypes = args
    .map((arg) => {
      const camelName = toCamelCase(arg.name);
      return `${camelName}: ${getTypeForArg(arg)}`;
    })
    .join("; ");

  return `args: { ${argsTypes} }, `;
}

function generateClarityArgs(args: readonly any[]): string {
  if (args.length === 0) return "";

  return args
    .map((arg) => {
      const argName = `args.${toCamelCase(arg.name)}`;
      return generateClarityConversion(argName, arg);
    })
    .join(", ");
}
